<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Climate Time Series Chart</title>
    <script type="text/javascript" src="https://d3js.org/d3.v5.js"></script>
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>

  <body>
    <div id="container" class="svg-container"></div>
    <script>
      //------------------------1. PREPARATION-------------------------//
      //-----------------------------SVG-------------------------------//
      const width = 1080;
      const height = 500;
      const margin = 5;
      const padding = 5;
      const adj = 30;
      // we are appending SVG first
      const svg = d3
        .select("div#container")
        .append("svg")
        .attr("preserveAspectRatio", "xMinYMin meet")
        .attr(
          "viewBox",
          "-" +
            adj +
            " -" +
            adj +
            " " +
            (width + adj * 3) +
            " " +
            (height + adj * 3)
        )
        .style("padding", padding)
        .style("margin", margin)
        .classed("svg-content", true);

      //-----------------------------DATA------------------------------//
      const timeConv = d3.timeParse("%m/%Y");
      const dataset = d3.csv("data/climate.data.donald");
      dataset.then(function(data) {
        const slices = data.columns.slice(2).map(function(id) {
          return {
            id: id,
            values: data.map(function(d) {
              return {
                date: timeConv(d.Mo + "/" + d.Year),
                measurement: +d[id]
              };
            })
          };
        });

        console.log("Column headers", data.columns);
        console.log("Column headers without date", data.columns.slice(1));
        // returns the sliced dataset
        console.log("Slices", slices);
        // returns the first slice
        console.log("First slice", slices[0]);
        // returns the array in the first slice
        console.log("A array", slices[0].values);
        // returns the date of the first row in the first slice
        console.log("Date element", slices[0].values[0].date);
        // returns the array's length
        console.log("Array length", slices[0].values.length);

        //----------------------------SCALES-----------------------------//
        const xScale = d3.scaleTime().range([0, width]);
        const yScale = d3.scaleLinear().rangeRound([height, 0]);

        xScale.domain(
          d3.extent(data, function(d) {
            return timeConv(d.Mo + "/" + d.Year);
          })
        );
        yScale.domain([
          d3.min(slices, function(c) {
            return d3.min(c.values, function(d) {
              return d.measurement - 1.5;
            });
          }),
          d3.max(slices, function(c) {
            return d3.max(c.values, function(d) {
              return d.measurement + 1.5;
            });
          })
        ]);

        //-----------------------------AXES------------------------------//

        const yaxis = d3.axisLeft().scale(yScale);
        const xaxis = d3.axisBottom().scale(xScale);
        //----------------------------LINES------------------------------//

        //-------------------------2. DRAWING----------------------------//

        //-----------------------------AXES------------------------------//
        svg
          .append("g")
          .attr("class", "axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xaxis);

        svg
          .append("g")
          .attr("class", "axis")
          .call(yaxis);

        //----------------------------LINES------------------------------//
        const line = d3
          .line()
          .x(function(d) {
            return xScale(d.date);
          })
          .y(function(d) {
            return yScale(d.measurement);
          });

        let id = 0;
        const ids = function() {
          return "line-" + id++;
        };

        const lines = svg
          .selectAll("lines")
          .data(slices)
          .enter()
          .append("g");

        lines
          .append("path")
          .attr("class", ids)
          .attr("d", function(d) {
            return line(d.values);
          });

        lines
          .append("text")
          .attr("class", "serie_label")
          .datum(function(d) {
            return {
              id: d.id,
              value: d.values[d.values.length - 1]
            };
          })
          .attr("transform", function(d) {
            return (
              "translate(" +
              (xScale(d.value.date) + 10) +
              "," +
              (yScale(d.value.measurement) + 5) +
              ")"
            );
          })
          .attr("x", 5)
          .text(function(d) {
            return d.id;
          });

        //----------------------------TREND------------------------------//
        // get the x and y values for least squares
        var xSeries = d3.range(1, xLabels.length + 1);
        var ySeries = data.map(function(d) {
          return parseFloat(d["rate"]);
        });

        var leastSquaresCoeff = leastSquares(xSeries, ySeries);

        // apply the reults of the least squares regression
        var x1 = xLabels[0];
        var y1 = leastSquaresCoeff[0] + leastSquaresCoeff[1];
        var x2 = xLabels[xLabels.length - 1];
        var y2 = leastSquaresCoeff[0] * xSeries.length + leastSquaresCoeff[1];
        var trendData = [[x1, y1, x2, y2]];

        var trendline = svg.selectAll(".trendline").data(trendData);

        trendline
          .enter()
          .append("line")
          .attr("class", "trendline")
          .attr("x1", function(d) {
            return xScale(d[0]);
          })
          .attr("y1", function(d) {
            return yScale(d[1]);
          })
          .attr("x2", function(d) {
            return xScale(d[2]);
          })
          .attr("y2", function(d) {
            return yScale(d[3]);
          })
          .attr("stroke", "black")
          .attr("stroke-width", 1);
      });

      // returns slope, intercept and r-square of the line
      function leastSquares(xSeries, ySeries) {
        var reduceSumFunc = function(prev, cur) {
          return prev + cur;
        };

        var xBar = (xSeries.reduce(reduceSumFunc) * 1.0) / xSeries.length;
        var yBar = (ySeries.reduce(reduceSumFunc) * 1.0) / ySeries.length;

        var ssXX = xSeries
          .map(function(d) {
            return Math.pow(d - xBar, 2);
          })
          .reduce(reduceSumFunc);

        var ssYY = ySeries
          .map(function(d) {
            return Math.pow(d - yBar, 2);
          })
          .reduce(reduceSumFunc);

        var ssXY = xSeries
          .map(function(d, i) {
            return (d - xBar) * (ySeries[i] - yBar);
          })
          .reduce(reduceSumFunc);

        var slope = ssXY / ssXX;
        var intercept = yBar - xBar * slope;
        var rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);

        return [slope, intercept, rSquare];
      }
    </script>
  </body>
</html>
